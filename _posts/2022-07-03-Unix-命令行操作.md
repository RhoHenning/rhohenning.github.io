---
title: Unix 命令行操作
date: 2022-07-03
categories:
- 笔记
tags:
- 命令行
- Unix
---

## Unix 命令基础

Unix 系统的命令行一般可以通过终端打开。进入终端后看到的的命令提示符如下，`$` 前面会显示当前目录，这里为 `~`。

```
finlay@server:~ $ 
```

在 `$` 后面输入命令。多条命令可以一次性输入，用 `;` 分隔。命令名和文件名可以按 <kbd>Tab</kbd> 键自动补全。

<!-- more -->

如果要重复执行之前执行过的命令，有如下方式：

- 上下方向键选择执行过的命令。
- `!<前缀>` 执行上一次具有指定前缀的命令。
- `history` 命令列出最近执行过的命令。

`man <命令>` 命令可以查看指定命令的使用手册。

---

## 目录与文件操作

### 目录访问

Unix 系统只有一个根目录 `/`，根目录下有系统默认的主目录 `/home`（有的系统下为 `/Users`），每位用户的主目录都存放在此目录下，即 `/home/<用户名>`。在 Unix 命令中，用 `~` 表示当前用户的主目录，`~` 后面加用户名表示该用户的主目录，例如，`~john` 和 `/home/john` 都表示用户 `john` 的主目录。

另外，`.` 表示当前目录，`..` 表示上层目录。

使用 `pwd` 命令可以显示当前目录。进入终端时，当前目录默认为当前用户的主目录。

`cd <目录>` 命令可以修改当前目录。例如，`cd /bin` 进入 `/bin` 目录，`cd ./folder` 或 `cd folder` 进入当前目录下的 `folder` 子目录，目录名可以按 <kbd>Tab</kbd> 键自动补全。`cd ..` 进入上一层目录，`cd ../..` 进入上上层目录。单独的 `cd` 相当于 `cd ~`，进入当前用户的主目录。`cd -` 回到刚才的目录，可用于两个目录之间的来回切换。

`ls` 命令可以列出当前目录下的文件，相当于 Windows 系统下的 `dir` 命令。`ls <目录>` 命令可以列出指定目录下的文件。

如果给 `ls` 命令添加 `-l` 选项，即 `ls -l`，则以长列表的方式列出文件的详细信息。如果添加 `-a` 选项，即 `ls -a`，则列出所有文件，包括隐藏文件。隐藏文件通常第一个字符为 `.` 。`ls -al` 同时添加两个选项。

在 Unix 系统下，如果要执行当前目录下的可执行文件 `prog`，只能使用 `./prog`，不能直接输入文件名 `prog`，除非当前目录在环境变量 `PATH` 中。`PATH` 描述了命令行寻找目标文件的范围。

### 文件管理

`*` 表示所有文件。例如，`/bin/*` 表示 `/bin` 目录下的所有文件，`./*` 或 `*` 表示当前目录下的所有文件。

`cp <源文件> <目标>` 命令可以复制文件，复制的目标可以是文件，也可以是目录。如果源文件中包含目录，要将目录中的内容一并复制，需要添加 `-r` 选项（表示递归）。`mv <源文件> <目标>` 命令可以移动文件。移动的目标是文件时，相当于将源文件重命名。例如，`mv old new` 将当前目录下的 `old` 文件重命名为 `new`。

`rm <文件>` 命令可以删除文件。例如，`rm folder/*` 将当前目录下的 `folder` 子目录的内容全部删除。该命令删除的文件不能从回收站中找回。

`mkdir <目录>` 命令可以新建目录，`rmdir <目录>` 命令可以删除目录。但用 `rmdir` 删除目录时必须要求该目录为空。如果要删除非空目录，可以使用 `rm -rf <目录>`，其中 `-r` 选项表示递归，`-f` 选项表示强迫删除。

### 文件查看

`more <文件>` 命令可以分屏显示文件内容。按空格显示下一屏，按 <kbd>q</kbd> 键退出。`cat <文件>` 命令可以显示文本内容，但不会分屏显示。

`head <文件>` 命令可以显示文件前若干行内容。默认显示前 $10$ 行，添加 `-n <行数>` 选项可以指定显示的行数。

`tail <文件>` 命令可以显示文件后若干行内容。默认显示后 $10$ 行，添加 `-n <行数>` 选项可以指定显示的行数。如果添加 `-f` 选项，则实时显示更新的文件内容，常用于在程序运行时查看日志文件。

`touch <文件>` 命令可以修改文件时间，但不修改文件的内容。如果文件不存在，则会创建新文件。

`grep <模式> <文件>` 命令可以查找指定模式在文件内容中出现的位置。如果添加 `-n` 选项，则显示这些位置所在行的行号。如果添加 `-w` 选项，则只查找完整单词。如果添加 `-i` 选项，则不区分大小写。

`wc <文件>` 命令可以显示文件的行数、字数、字符数。如果添加 `-l` 选项，则只显示行数。如果添加 `-w` 选项，则只显示字数。如果添加 `-c` 选项，则只显示字符数。

### 重定向与管道

`>` 把命令的输出重定向到文件，`<` 把命令的输入重定向到文件。例如，`./prog < data.in > data.out` 执行当前目录下的可执行文件 `prog`，从 `data.in` 中输入，向 `data.out` 中输出。

由于 `cat`命令会显示标准输入的内容，可以用 `cat > file` 从标准输入中读取内容并写入 `file` 文件，按 <kbd>Ctrl</kbd>+<kbd>D</kbd> 结束输入。

`|` 把前一个命令的输出作为后一个命令的输入。例如，如果当前目录下的文件较多，可以用 `ls -l | more` 分屏显示详细信息，用 `ls | grep an | wc -l` 显示当前目录下有多少个名字包含 `an` 的文件。

---

## 进程管理

`ps` 命令列出当前终端下的进程。如果添加 `ax` 选项，即 `ps ax`，则列出系统中的所有进程。`top` 命令实时查看进程。按 <kbd>q</kbd> 键退出。

如果有进程正在前台执行，可以按 <kbd>Ctrl</kbd>+<kbd>C</kbd> 结束进程，否则可以使用 `kill <进程号>` 命令。进程号（PID）可以通过 `ps` 或 `top` 命令查看。如果无法结束进程，可以添加 `-9` 选项来强制结束进程。

有时该进程由超级用户启动，以普通用户的身份无法结束进程。如果该普通用户在系统的 `sudo` 列表中，可以使用 `sudo` 命令伪装 `root` 用户的身份执行命令，即 `sudo kill -9 <PID>`。使用 `sudo` 时需要输入该普通用户的密码。

有进程正在前台执行时，也可以按 <kbd>Ctrl</kbd>+<kbd>Z</kbd> 暂停进程。

`bg` 命令可以将前台进程放到后台继续运行。`bg <进程工作号>` 命令可以将指定进程放到后台运行，进程工作号可以通过 `jobs` 命令查看。`fg` 命令将后台进程放到前台运行，用法与 `bg` 命令类似。

在命令后面加上 `&` ，可以直接将该命令放到后台执行。

---

## 环境变量

Unix 系统下的 `cp`、`ls` 等命令实际上是 `/bin` 目录下的可执行文件。而该目录下的可执行文件可以不加目录直接执行，因为该目录包含在环境变量 `PATH` 中。

`set` 命令可以显示环境变量。用 `set | grep PATH` 可以从中查看 `PATH` 变量，其中包含了若干个目录，不同的目录之间用 `:` 分隔。命令行会在 `PATH` 包含的目录中寻找可执行文件，因此这些目录下的可执行文件可以不加目录直接执行。

假设有一个可执行文件 `prog`，放在 `~/bin` 目录下，我们希望可以输入 `prog` 就能直接执行，那么就需要将该目录添加进 `PATH` 变量中。可以使用如下命令：

```
$ PATH=$PATH:~/bin
```

但这样添加的目录 `~/bin` 在下一次登录终端时就会失效。

如果要让添加的目录长久有效，需要自己编写配置文件。在根目录下有一些用于配置的文件，如 `/etc/profile`，该文件在每次登录终端时都会执行。我们可以在主目录下创建一个隐藏文件 `~/.profile`，并写入

```
PATH=$PATH:~/bin
```

则下一次登录终端时，`~/bin` 目录就被添加进了环境变量中。如果要立刻见效，可以使用如下命令：

```
$ source .profile
```

---

## 网络调试

### 网络配置

`ifconfig` 命令可以列出所有网卡的信息。`ifconfig <网卡>` 命令可以列出指定网卡的信息。

`ifconfig <网卡> down` 命令可以关掉指定网卡，`ifconfig <网卡> up` 命令可以启用指定网卡。

`ifconfig <网卡> add <IP 地址> netmask <子网掩码>` 命令可以给指定网卡添加子网。`ifconfig <网卡> del <IP 地址>` 命令可以删除指定网卡的子网。

`ifconfig <网卡> <IP 地址>` 命令可以修改指定网卡的 IP 地址。

`netstat` 命令可以列出网络状态。常用的选项有：

- `-l` 选项：列出正在监听的状态。
- `-t` 选项：只列出 TCP 相关选项。
- `-u` 选项：只列出 UDP 相关选项。
- `-s` 选项：按照各个协议进行统计。
- `-p` 选项：列出相关进程信息。
- `-c` 选项：实时更新网络状态信息，按 <kbd>Ctrl</kbd>+<kbd>C</kbd> 退出。
- `-r` 选项：查看路由信息。
- `-i` 选项：查看接口情况。

### 网络通信

`nc -l -p <端口号>` 命令可以作为服务器监听指定端口。

以下命令在服务器（IP 地址为 `192.168.1.22`）的 `8080` 端口激活监听。

```
finlay@server:~ $ nc -l -p 8080
```

`telnet <IP 地址> <端口号>` 命令可以远程登录服务器的指定端口。

以下命令让客户端登录服务器的 `8080` 端口，按 <kbd>Ctrl</kbd>+<kbd>]</kbd> 退出。

```
guest@client:~ $ telnet 192.168.1.22 8080
```

至此客户端和服务器之间可以相互通信。

---

## 远程登录

TELNET 和 FTP 协议并不安全。连接远程服务器更常采用 SSH。

`ssh <IP 地址>` 命令可以远程登录服务器的默认端口。添加 `-p <端口号>` 选项可以指定端口。

默认使用客户端登录的用户名来登录远程服务器。如果要指定登录的用户名，需要使用 `ssh <用户名>@<IP 地址>`。

以下命令用用户名 `finlay` 登录服务器的默认端口。

```
guest@client:~ $ ssh finlay@192.168.1.22
```

输入密码后，如果登录成功，命令提示符会改变。

```
finlay@server:~ $
```

可以用 `whoami` 命令查看用户名，或者用 `w` 命令查看当前设备登录的用户。

任何知道密码的人都能成功登录，即使不知道密码，也能尝试去登录，因此这种登录方式仍然不够安全。

### 设置密钥

下面在服务器创建一个名为 `test` 的用户。

```
finlay@server:~ $ sudo adduser test
```

输入密码并确认信息。此时在客户端可以通过用户名和密码进行登录。

在客户端用以下命令产生一对密钥，存储在 `~/.ssh/test22` 目录下。

```
guest@client:~ $ ssh-keygen -f ~/.ssh/test22
```

输入 passphrase 后，在该目录下产生了公钥 `test22.pub` 和私钥 `test22`。下面将公钥传到服务器上去。

进入 `~/.ssh` 目录，使用以下命令。

```
guest@client:~/.ssh $ sftp test@192.168.1.22
```

输入密码后，即连接上服务器。然后输入以下命令，将公钥传至服务器后退出。

```
sftp> put test22.pub
sftp> bye
```

此时再登录服务器上的 `test` 用户，就能在目录下发现 `test22.pub` 公钥文件。把公钥文件移至 `~/.ssh` 目录下。

```
test@server:~ $ mkdir .ssh
test@server:~ $ mv test22.pub .ssh
```

公钥文件还需要认证。用以下命令在该目录下新建 `authorized_keys` 文件后退出用户。

```
test@server:~ $ cd .ssh
test@server:~/.ssh $ cat test22.pub > authorized_keys
test@server:~/.ssh $ exit
```

至此，在客户端可以直接用私钥登录服务器上的 `test` 用户，不需要输入密码。

```
guest@client:~ $ ssh -i ~/.ssh/test22 test@192.168.1.22
```

还可以用以下指令删除 `test` 用户的密码。

```
finlay@server:~ $ sudo passwd -d test
```

这样无论如何都是不能通过密码登录 `test` 账户的，只能用私钥登录，因此更为安全。

### 系统配置

私钥登录的命令比较长，可以进行如下配置：

将全局配置文件 `/etc/ssh/ssh_config` 复制到自己的目录下（如 `~/.ssh`），然后改名为 `config`。

```
guest@client:~ $ cp /ect/ssh/ssh_config .ssh
guest@client:~ $ mv .ssh/ssh_config .ssh/config
```

向该文件中加入以下内容：

```
Host test22
	user test
	port 22
	hostname 192.168.1.22
	identityfile ~/.ssh/test22
```

至此可以直接用以下命令远程登录。

```
guest@client:~ $ ssh test22
```

---

## 编译与调试

### `gcc` 编译

`gcc <.c 文件>` 命令对指定的 `.c` 文件进行编译。如果添加 `-o <文件名>` 选项，则会产生可执行文件。如果添加 `-c` 选项，则只产生 `.o` 文件，不进行链接。`--save-temps` 选项可以保留编译的中间结果，包括 `.i` 文件、`.s` 文件、`.o` 文件等。

以 `main.c`、`sum.c` 两个 `.c` 文件以及 `sum.h` 一个 `.h` 文件为例。可以使用如下命令编译两个 `.c` 文件，产生可执行文件 `sum`。

```
$ gcc main.c sum.c -o sum
```

然后使用 `./sum` 命令执行该文件。

对于文件较多的情况，可以编写 Makefile 文件，然后使用 `make` 命令。Makefile 文件的编写方法见后文。

### `gdb` 调试

使用 `gdb <文件>` 命令调试可执行文件。源代码在用 `gcc` 编译时需要添加 `-g` 选项，用于产生调试信息。

```
$ gdb sum
```

常用的调试命令如下。

- `quit`（`q`）命令结束调试。
- `run`（`r`）命令重新开始运行程序。
- `break`（`b`）命令在当前位置设置断点，`break <函数名>`（`b <函数名>`）命令在指定函数处设置断点，`break <行号>`（`b <行号>`）命令在指定的行设置断点。`break` 命令后面可以加上 `if` 作为条件。
- `info breakpoints` 命令查看当前设置的所有断点的信息。
- `delete breakpoints <断点号>`（`d <断点号>`）命令取消断点。断点的编号可以通过 `info breakpoints` 查看。
- `print <变量名>`（`p <变量名>`）命令显示变量的信息。
- `info local` 命令查看所有本地变量的信息。
- `list`（`l`）命令查看代码，`list <函数名>`（`l <函数名>`）命令查看指定函数附近的代码，`list <行号>`（`l <行号>`）命令查看指定行的代码。
- `step`（`s`）命令执行当前行（会进入函数内部）。
- `next`（`n`）命令执行当前行（不会进入函数内部）。
- `continue`（`c`）命令继续运行。

### 静态库

为了保护源码、避免重复编译，通常将头文件的源码编译成 `.o` 文件后打包成库。静态库（`.a` 文件）在编译时会被链接到目标代码中，程序执行时不需要库。动态链接库（`.so` 文件）不包含在目标代码中，程序执行时需要装载和使用动态链接库中的函数。嵌入式系统中通常使用静态库。

先用 `gcc -c <.c 文件>` 命令编译得到 `.o` 文件，然后用 `ar rcs <文件名> <.o 文件>` 命令将一个或多个 `.o` 文件打包成库文件。库文件名应为 `lib<库名>.a`。

在本例中，如果要把 `sum.c` 文件打包成库，则可以使用如下命令。

```
$ gcc -c sum.c
$ ar rcs libsum.a sum.o
```

此时仍可以把 `.a` 文件和 `.o` 文件直接链接产生可执行文件。但更通用的方法是使用 `-l <库名>` 选项，这里的库名不包含 `lib` 和 `.a`。例如，`-lsum` 表示链接时加入 `sum` 库，对应的库文件为 `libsum.a`。

默认情况下，编译器会从系统的库文件目录中寻找库文件，可以用 `-L <目录>` 选项指定库文件的目录。例如，`-L.` 表示在当前目录下寻找库文件。

```
$ gcc -o sum main.c -L. -lsum
```

---

## Makefile 文件

Makefile 文件描述了文件编译和链接的规则，包括如何编译源文件、创建库文件、生成可执行文件，而 `make` 命令解释执行这些规则。

Makefile 文件中，`#` 表示注释，`\` 为续行符。

### 依赖关系

最终的可执行文件 `sum` 由 `main.o`、`sum.o` 链接得到，因此 `sum` 依赖于这两个 `.o` 文件。`.o` 文件由对应的 `.c` 文件编译得到，而 `.c` 文件又包含了 `.h` 文件 `sum.h`，因此 `.o` 文件依赖于 `.c` 文件和 `.h` 文件。

依赖关系体现为：一旦目标所依赖的其中一个文件进行了修改，目标就需要重新编译。根据依赖关系可以初步写出 Makefile 文件。

```
sum: main.o sum.o
	gcc main.o sum.o -o sum

main.o: main.c sum.h
	gcc -c main.c

sum.o: sum.c sum.h
	gcc -c sum.c
```

其中 `:` 前的文件为依赖的目标，`:` 后的文件为目标所依赖的文件，两者都可以包含多个文件。每一个目标下面包含一条或多条命令。Makefile 文件正是有了这些依赖关系，才能确定哪些文件是需要重新编译的，从而避免重复编译。

### Makefile 变量

Makefile 文件能自动处理同名的 `.o` 文件和 `.c` 文件的依赖关系，所以可以这样写：

```
sum: main.o sum.o
	gcc main.o sum.o -o sum

main.o sum.o: sum.h

%.o: %.c
	gcc -c $<
```

其中 `$<` 是系统默认变量，表示所依赖的文件中的第一个文件。最后两行用统一的规则说明了源代码的编译方式，其中的 `%.o: %.c` 可以替换为 `.c.o:`。如果没有最后两行，那么 Makefile 会自动用 `cc` 编译。这在 Windows 系统上很可能不可行。

为了文件调整和修改方便，可以进一步借助变量，于是上述文件可以改成：

```
CC = gcc
OBJS = main.o sum.o
TARGET = sum

$(TARGET): $(OBJS)
	$(CC) $^ -o $@

%.o: %.c
	$(CC) -c $<
```

> 从这里开始，本文展示的 Makefile 文件中不再体现包含 `.h` 文件的依赖关系。后文会给出更通用的解决方法。

其中 `CC`、`OBJS`、`TARGET` 是自定义变量； `$^` 和 `$@` 都是系统默认变量，前者表示所依赖的所有文件，后者表示依赖的目标。

借助 `echo <字符串>` 命令可以输出对应的依赖关系，命令前加 `@` 可以使命令本身不被输出，如：

```
$(TARGET): $(OBJS)
	@echo $@
	@echo $^
	$(CC) $^ -o $@
```

则链接生成可执行文件时的输出为：

```
sum
main.o sum.o
gcc main.o sum.o -o sum
```

### 多目标

Makefile 文件的第一个目标为主目标。`make` 命令默认执行主目标，而 `make <目标名>` 命令可以执行指定目标。

例如，用伪目标 `clean`、`cleanall` 在 Makefile 里实现编译后清理文件的功能。

```
clean:
	rm $(OBJS)

cleanall: clean
	rm $(TARGET)
```

其中 `rm $(OBJS)` 删除所有的 `.o` 文件，更一般地可以写成 `rm *.o`。此时就可以使用 `make clean` 命令删除所有 `.o` 文件，使用 `make cleanall` 命令删除 `.o` 文件和可执行文件。

又例如，当前目录下新建一个 `test.c` 文件用于测试，用目标 `test` 编译 `test.c`，生成另外一个可执行文件 `test`。

```
TESTOBJS = test.o sum.o
TESTTARGET = test

$(TESTTARGET): $(TESTOBJS)
	$(CC) $^ -o $@
```

还可以用目标 `all` 同时生成可执行文件 `sum` 和 `test`。

```
all: $(TARGET) $(TESTTARGET)
```

### 命令参数

`make` 命令的参数可以作为值传递给 Makefile 文件中的变量。例如，目标 `test` 编译产生可执行文件 `test`，该文件接受一个命令行参数。Makefile 中用变量 `$(ARGS)` 表示向可执行文件 `test` 传递的命令行参数。

```
$(TESTTARGET): $(TESTOBJS)
	$(CC) $^ -o $@
	./$(TESTTARGET) $(ARGS)
```

此时就需要在用 `make` 命令执行目标的同时提供变量 `$(ARGS)` 的值。如

```
$ make ARGS=123 test
```

此时在 `test.c` 中读到的 `argv[1]` 即为 `"123"`。

如果在 `test.c` 里有一处使用了未定义的宏 `ARGS`，需要在编译时将宏定义为 `123`，则可以在编译时使用

```
$ gcc -D ARGS="123" -c test.c
```

也可以直接在使用 `make` 命令时添加参数，即

```
$ make ARGS="123" test
```

这里的 `""` 说明这是一个宏的值，并不属于宏的内容。如果宏本身是带 `""` 的字符串，如 `"123"`，则其中的 `ARGS="123"` 需要改为 `ARGS='"123"'` 或 `ARGS=\"123\"`。

### 自动依赖

在用 `gcc` 编译时，使用`-MMD` 选项可以分析其中的头文件，产生 `.d` 文件。`.d` 文件中包含了 `.o`、`.c`、`.h` 文件的依赖关系说明。

例如，`main.d` 的内容为：

```
main.o: main.c main.h
```

因此在 Makefile 文件的编译选项中添加 `-MMD`，用来产生 `.d` 文件。

```
CFLAG = -MMD

sum: $(OBJS)
	$(CC) $(CFLAG) $^ -o $@
```

这样的话原来包含 `.h` 文件的依赖关系的说明 `$(OBJS): sum.h` 就可以改为

```
DEPS = $(OBJS:.o=.d)

-include $(DEPS)
```

其中 `$(OBJS:.o=.d)` 表示将 `OBJS` 变量中所有的 `.o` 替换为 `.d`。因此 `-include $(DEPS)` 就将所有 `.d` 文件的内容插入到了 Makefile 文件中。不过要注意的是，第一次编译产生的 `.d` 文件需要在第二次用 `make` 命令的时候才会被包含在 Makefile 文件中。