---
title: 排序算法汇总
date: 2018-11-08
categories:
- C/C++
tags:
- 排序
---

本文默认的排序方式为将 $a_1,a_2,\cdots,a_n$ 从小到大排序。

## 比较型排序算法

### 选择排序

每次选择剩余的元素中最小的一个，放在已排好序的元素后面。具体实现时，直接在原序列上进行，从前往后讨论，从 $a_i,a_{i+1},\cdots,a_n$ 中选出最小的元素，即整个序列第 $i$ 小的元素，将其与 $a_i$ 交换。时间复杂度为 $O(n^2)$。

若存在 $a_i=a_j>a_k(1\le i<j<k\le n)$，则 $a_i$ 与 $a_k$ 交换后位于 $a_j$ 的后面，因此选择排序是**不稳定**的排序算法。

<!-- more -->

```cpp
void selection_sort(int *a, int n) {
  for(int i = 1; i < n; i++)
    for(int j = i+1; j <= n; j++)
      if(a[i] > a[j]) swap(a[i], a[j]);
}
```

若“每次选择剩余的元素中最小的一个”用堆来实现，该算法就成了堆排序。

### 冒泡排序

从前往后讨论相邻两项，若前者大于后者，则交换两者的位置。类比求序列中元素的最大值，可知经过一次讨论后序列中最大的元素被交换到了最后一个位置。再对剩余元素不断重复上述过程。时间复杂度为 $O(n^2)$。

若序列中含有相同元素，当两者被交换到相邻位置时，根据交换的条件“前者大于后者”，两者不进行交换，即相对位置不变。因此冒泡排序是**稳定**的排序算法。

```cpp
void bubble_sort(int *a, int n) {
  for(int i = 1; i < n; i++)
    for(int j = 1; j < n; j++)
      if(a[j] > a[j+1]) swap(a[j], a[j+1]);
}
```

### 插入排序

每次将一个未排序的元素 $a_i$ 插入到已排好序的元素序列中的正确位置，即前一个元素小于等于 $a_i$，后一个元素大于等于 $a_i$；其后的元素需要顺次后移一位。时间复杂度为 $O(n^2)$。如果从后往前寻找插入的位置，找到最后一个小于等于 $a_i$ 的元素，将 $a_i$ 插入其后，则可以保证相同元素的相对顺序不变，因此插入排序是**稳定**的。

```cpp
void insertion_sort(int *a, int n) {
  for(int i = 2; i <= n; i++) {
    int t = a[i], j = i-1;
    while(j > 0 && a[j] > t) a[j+1] = a[j--];
    a[j+1] = t;
  }
}
```

### 归并排序

归并排序采用分治思想。将序列分成两个子序列，先将两个子序列分别排好序，再合并成一个有序的序列。于是问题的关键在于如何将两个有序的序列合并，且合并后整个序列仍然有序。

依旧使用选择排序的思路：每次选择剩余的元素中最小的一个。只不过由于两个子序列都有序，每个子序列取剩余的元素中最小的一个，再选择两者当中的较小者；并且由于子序列有序，取子序列中剩余元素的最小者时，从前往后依次选取即可。为了保留两个有序的子序列，合并的新序列需要额外的存储空间。

时间复杂度为 $O(n\log n)$。

在合并两个子序列时，如果遇到相同的元素，可以先将左边子序列当中的元素加入合并后的序列中，这样相对顺序不变，因此归并排序是**稳定**的。

```cpp
const int maxn = 1e5+5;
int t[maxn];

void merge_sort(int *a, int l, int r) {
  if(l >= r) return;
  int mid = l+r>>1, i = l, j = mid+1, k = l;
  merge_sort(a, l, mid);
  merge_sort(a, mid+1, r);
  while(i <= mid || j <= r) {
    if(j > r || i <= mid && a[i] <= a[j]) t[k++] = a[i++];
    else t[k++] = a[j++];
  }
  for(i = l; i <= r; i++) a[i] = t[i];
}
```

#### 求逆序对数

设两个子序列为 $a_l,a_{l+1},\cdots,a_{mid}$ 和 $a_{mid+1},a_{mid+2},\cdots,a_r$（分别有序），且两个子序列的剩余的最小元素分别为 $a_i,a_j(l\le i\le mid<j\le r)$，即第一个子序列的前 $i-l+1$ 个元素、第二个子序列的前 $j-mid$ 个元素已经加入合并后的序列。若 $a_i>a_j$，则应将 $a_j$ 加入合并后的序列。

当 $a_{i-1}$ 存在时，一定有 $a_{i-1}\le a_j$，否则 $a_{i-1}$ 加入合并后的序列之前 $a_j$ 就应先加入。据此可得

$$a_l\le a_{l+1}\le\cdots\le a_{i-1}\le a_j<a_i\le a_{i+1}\le\cdots\le a_{mid}$$

又因为

$$l<l+1<\cdots<i-1<i<i+1<\cdots<mid<j$$

所以 $a_j$ 与 $a_i,a_{i+1},\cdots,a_{mid}$ 都构成了逆序对，与 $a_l,a_{l+1},\cdots,a_{i-1}$ 都不构成逆序对。

综上，当右边子序列中的 $a_j$ 需要加入合并后的序列中时，$a_j$ 对整个序列的逆序对数的贡献为 $mid-i+1$。把归并排序的代码稍作修改即可**求逆序对数**：

```cpp
const int maxn = 1e5+5;
int t[maxn];

int reverse_count(int *a, int l, int r) {
  if(l >= r) return 0;
  int mid = l+r>>1, i = l, j = mid+1, k = l;
  int cnt = reverse_count(a,l,mid)+reverse_count(a,mid+1,r);
  while(i <= mid || j <= r) {
    if(j > r || i <= mid && a[i] <= a[j]) t[k++] = a[i++];
    else t[k++] = a[j++], cnt += mid-i+1;
  }
  for(i = l; i <= r; i++) a[i] = t[i];
  return cnt;
}
```

当某些算法需要分治与排序相结合时，经常使用归并排序。

### 快速排序

快速排序也采用了分治的思想，但在划分时要求左边子序列的最大元素小于右边子序列的最小元素，避免了两个子序列的合并过程。选取一个元素作为基准值，将比基准值小的元素放在该元素左边，比基准值大的元素放在该元素右边。问题的关键在于如何划分两个子序列。

对于当前序列 $a_l,a_{l+1},\cdots,a_r$，一种实现方法是：选取第一个元素 $a_l$ 作为基准值，先从右往左讨论位置 $j$，找到最右边的小于基准值的元素 $a_j$；然后从左往右讨论位置 $i$，找到最左边的大于基准值的元素 $a_i$；最后交换 $a_i,a_j$ 的值。经过上述过程后，$a_l,a_{l+1},\cdots,a_i$ 全部小于等于基准值，$a_j,a_{j+1},\cdots,a_r$ 全部大于等于基准值。重复该过程，将位置 $i,j$ 不断往中间靠拢，并交换沿途位置不正确的元素。最终，当位置 $j$ 继续向左移动时，会与位置 $i$ 重合，而此时位置 $i$ 处的值 $a_i$ 小于等于基准值，可以放在更靠前的位置，交换 $a_l,a_i$ 的值即可。最终基准值位于位置 $i$。

当一对相同的元素从基准值的一侧交换到另一侧时，其相对顺序自然发生改变，因此快速排序是**不稳定**的排序算法。

```cpp
void quick_sort(int *a, int l, int r) {
  if(l >= r) return;
  int i = l, j = r, t = a[l];
  while(i < j) {
    while(i < j && a[j] >= t) j--;
    while(i < j && a[i] <= t) i++;
    if(i < j) swap(a[i], a[j]);
  }
  swap(a[l], a[i]);
  quick_sort(a, l, i-1);
  quick_sort(a, i+1, r);
}
```

#### 求第 $k$ 小数

若要寻找序列中的**第 $k$ 小数**，不必对整个序列进行排序。可以利用快速排序划分子序列的方法，先找到基准值 $a_i$。若 $k=i$，则 $a_i$ 就是第 $k$ 小数；若 $k<i$，则进入左边的子序列寻找；若 $k>i$，则进入右边的子序列寻找。由于每次只需进入一个子序列，总时间复杂度为 $O(n)$。

```cpp
int kth_element(int *a, int k, int l, int r) {
  if(l >= r) return a[l];
  int i = l, j = r, t = a[l];
  while(i < j) {
    while(i < j && a[j] >= t) j--;
    while(i < j && a[i] <= t) i++;
    if(i < j) swap(a[i], a[j]);
  }
  swap(a[l], a[i]);
  if(k < i) return kth_element(a, k, l, i-1);
  if(k > i) return kth_element(a, k, i+1, r);
  return a[i];
}
```

一个长度为 $n$ 的序列的排列数为 $n!$，每一次比较两个元素的值最多排除掉一半的排列数，因此基于比较的排序算法的时间复杂度下限为 $O(\log n!)$。而

$$\dfrac{n}{2}\log\dfrac{n}{2}=\log\left(\dfrac{n}{2}\right)^{\tfrac{n}{2}}\le\log n!\le \log n^n=n\log n$$

所以

$$O(\log n!)=O(n\log n)$$

---

## 非比较型排序算法

### 计数排序

通过统计每个元素出现的次数，计算出每个元素的排名，再根据排名确定每个元素排序后的位置。

用 $c_x$ 记录值为 $x$ 的元素个数，则 $c_x$ 的前缀和表示 $x$ 在序列中的排名。若有相同的元素，每次将该元素的值对应的排名减 $1$，则下一个相同的元素位于该元素之前。因此只要在原序列中从后往前讨论元素，就能保证相同元素的相对顺序不变，所以计数排序是**稳定**的。

计数排序的时间复杂度为 $O(n+w)$，其中 $w$ 是元素的值域范围。

```cpp
const int maxn = 1e5+5;
int c[maxn], t[maxn];

void counting_sort(int *a, int n) {
  int w = 0;
  for(int i = 1; i <= n; i++) c[t[i]=a[i]]++, w = max(w, t[i]);
  for(int i = 1; i <= w; i++) c[i] += c[i-1];
  for(int i = n; i >= 1; i--) a[c[t[i]]--] = t[i];
}
```

### 基数排序

把所有元素拆分成 $k$ 个关键字，先按第 $k$ 个关键字对所有元素进行稳定排序，再按第 $k-1$ 个关键字对所有元素进行稳定排序……直到排完 $k$ 次序为止。若排序的元素是整数，则可取 $k$ 为最大元素的位数，从高到低第 $i$ 位的数字为第 $i$ 个关键字，则每个关键字的范围仅为 $[0,9]$，可用计数排序，总时间复杂度为 $O(nk)$。

下面这段代码可能有点晦涩。$d(i,j)$ 是 $a_i$ 的第 $j$ 个关键字，$id(i)$ 表示排完序后第 $i$ 个位置的元素是 $a_{id(i)}$。

```cpp
const int maxn = 1e5+5, maxk = 25;
int c[10], t[maxn], id[maxn], d[maxn][maxk];

void radix_sort(int *a, int n) {
  int w = 0, k = 0;
  for(int i = 1; i <= n; i++) id[i] = i, w = max(w,a[i]);
  while(w) w /= 10, k++;
  for(int i = 1; i <= n; i++) {
    int p = a[i];
    for(int j = k; j >= 1; j--) d[i][j] = p%10, p /= 10;
  }
  for(int j = k; j >= 1; j--) {
    for(int i = 0; i < 10; i++) c[i] = 0;
    for(int i = 1; i <= n; i++) c[d[t[i]=id[i]][j]]++;
    for(int i = 1; i < 10; i++) c[i] += c[i-1];
    for(int i = n; i >= 1; i--) id[c[d[t[i]][j]]--] = t[i];
  }
  for(int i = 1; i <= n; i++) t[i] = a[i];
  for(int i = 1; i <= n; i++) a[i] = t[id[i]];
}
```

这个方法初听可能觉得不自然，比较两个元素的大小不应该是先比较第一个关键字吗？先按第一个关键字排序也并非不可，只是需要将第一个关键字相同的元素划分成一个子序列，然后按第二个关键字对每一个子序列分别排序。而基数排序利用了稳定排序算法的特点，先按第 $k$ 个关键字排序后，再按第 $k-1$ 个关键字排序时，对于第 $k-1$ 个关键字相同的元素，其第 $k$ 个关键字已经有序了。这样每次排序都对所有的元素进行，避免了划分子序列的操作。

### 桶排序

如果采用按照第一个关键字划分子序列的方法，划分后的子序列的值域一定是不相交的，某个子序列中的元素要么全部大于另一个子序列中的所有元素，要么全部小于另一个子序列中的所有元素。这与快速排序划分两个子序列的效果类似，只需对每个子序列分别排序，最后直接拼接。

于是得到桶排序：划分出的一个子序列对应一个桶，对每个桶内的元素分别排序。代码中采用的是插入排序。

```cpp
const int maxn = 1e5+5;
vector<int> buc[maxn];

void bucket_sort(int *a, int n) {
  int w = 0, tot = 0;
  for(int i = 1; i <= n; i++) w = max(w, a[i]);
  for(int i = 1; i <= n; i++) buc[a[i]/(w/n+1)].push_back(a[i]);
  for(int k = 0; k < n; k++) {
    for(int i = 1; i < buc[k].size(); i++) {
      int t = buc[k][i], j = i-1;
      while(j >= 0 && buc[k][j] > t) buc[k][j+1] = buc[k][j--];
      buc[k][j+1] = t;
    }
    for(int i = 0; i < buc[k].size(); i++) a[++tot] = buc[k][i];
  }
}
```

基数排序和桶排序的稳定性是由其内部使用的其它排序算法决定的。基数排序要求使用稳定排序算法，因此基数排序是**稳定**的。不过事实上，基数排序中的第一次排序（按第 $k$ 个关键字排序）可以不使用稳定排序，此时基数排序就是不稳定的。
